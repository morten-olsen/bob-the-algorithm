{"version":3,"sources":["src/features/appointments/context.ts","src/features/async/hooks.ts","src/features/data/types.ts","src/features/data/utils.ts","src/features/day/context.ts","src/features/day/utils.ts","src/features/day/provider.tsx","src/features/day/hooks.ts","src/features/appointments/providers/native.ts","src/features/appointments/provider.tsx","src/utils/data-context.tsx","src/features/goals/context.ts","src/features/location/context.ts","src/features/location/provider.tsx","src/features/location/hooks.ts","src/features/overrides/context.ts","src/features/overrides/provider.tsx","src/features/planner/algorithm/utils.ts","src/features/planner/algorithm/get-next.ts","src/features/planner/algorithm/build-graph.ts","src/features/planner/context.ts","src/features/routines/context.ts","src/features/routines/hooks.ts","src/features/goals/hooks.ts","src/features/planner/algorithm/construct-day.ts","src/features/planner/hooks.ts","src/features/overrides/hooks.ts","src/features/appointments/hooks.ts","src/features/setup.tsx","src/features/tasks/hooks.tsx","src/ui/containers/tasks/group.tsx","src/ui/screens/day/index.tsx","src/ui/screens/task/add.tsx","src/ui/screens/more/index.tsx","src/ui/screens/locations/list.tsx","src/ui/screens/locations/set.tsx","src/ui/screens/task/list.tsx","src/ui/screens/task/overrides.tsx","src/ui/containers/plan/day/task.tsx","src/ui/containers/plan/day/index.tsx","src/ui/screens/plan/index.tsx","src/ui/router/router.tsx","src/index.ts","src/app.tsx"],"names":["AppointmentsStatus","useAsyncCallback","fn","deps","useState","result","setResult","prevArgs","setPrevArgs","loading","setLoading","error","setError","action","useCallback","invoke","a","async","args","output","undefined","useMemo","useAsync","options","useEffect","localOptions","rerun","TaskType","AppointmentsContext","createContext","largerThan","b","timeToMinutes","time","hour","minute","timeUtils","timeToString","input","stringToTime","split","map","trim","filter","Boolean","hourPart","minutePart","parseInt","Number","isInteger","isNaN","equal","timeToDate","Date","dateToTime","date","getHours","getMinutes","max","add","minutes","toAdd","current","Math","floor","DateContext","dateToDay","year","getFullYear","month","getMonth","getDate","dayUtils","today","dayToDate","day","toId","toString","padStart","DateProvider","children","setDate","Provider","value","useDate","useContext","NativeIntegtration","getAllCalendars","getCalendarsAsync","EntityTypes","EVENT","calendars","setup","Platform","OS","requestCalendarPermissionsAsync","status","getDay","selectedCalendars","start","end","set","hours","seconds","milliseconds","getEventsAsync","c","id","events","allDay","e","startTime","startDate","endTime","endDate","duration","type","appointment","calendarId","title","required","min","AppointmentsProvider","setProvider","unavailable","iosProvider","approved","createDataContext","createDefault","deserialize","Context","key","storageKey","setCurrent","next","AsyncStorageLib","setItem","JSON","stringify","setData","getItem","raw","parse","data","GoalsContext","GoalsProvider","LocationContext","LocationProvider","lookup","getTransition","locations","setLocations","AsyncStorage","location","index","remove","useLocations","Object","values","OverrideContext","OverrideProvider","currentDate","overrides","setOverrides","get","StorageKey","tasks","override","locationEqual","listContainLocation","list","target","find","l","getRemainingLocations","forEach","task","push","Strategies","isDead","impossible","t","getImpossible","remaining","calculateScore","transition","score","priority","getNext","currentNode","context","nextNodes","remainingLocations","remainingTasks","Promise","all","parent","to","impossibeTasks","completed","dead","possibleTasks","orgTask","parentRemainging","length","sleep","resolve","setTimeout","fil","Array","fill","i","buildGraph","strategy","allValid","callback","batchSize","sleepTime","nodeCount","running","leafList","completedList","deadList","complete","nodes","sort","node","pop","cancel","n","alive","firstValid","firstComplet","fullComplete","PlannerContext","PlannerProvider","RoutinesContext","RoutinesProvider","useRoutines","useGoals","constructDay","plans","name","from","reverse","getDays","stopDate","days","firstValue","arg","usePreparePlan","routines","goals","getOverrides","appointments","useGetAppointments","getAppontments","enabled","startMin","startMax","usePlan","preparePlan","createPlan","prepareOptions","prepared","reduce","update","dayGoal","graph","winner","plan","goal","d","Setup","getTransit","useTasks","useAppointments","routine","useSetTask","setRoutine","useSetRoutine","setGoal","useSetGoals","useRemoveTask","removeRoutine","useRemoveRoutine","removeGoal","useRemoveGoal","TaskGroup","navigate","useNavigation","items","getKey","render","onPress","Wrapper","styled","View","Content","ScrollView","DayScreen","appointmentStatus","startTimeOverride","useSetStartTimeOverride","setStartTimeOverride","selected","onSelect","label","onChange","SideBySide","dayNames","_","TaskAddScreen","useRoute","params","goBack","nanoid","currentId","setTask","currentType","setCurrentType","setTitle","maxStart","setMaxStart","minStart","setMinStart","setDuration","hasLocation","setHasLocation","selectedLocations","setSelectedLocations","hasDays","setHasDays","selectedDays","setSelectedDays","setRequired","save","onClose","onChangeText","flex","right","startHidden","setEnabled","disabledText","enabledText","MoreScreen","LocationListScreen","removeLocation","item","LocationSetScreen","setLocation","position","longitute","latitude","TaskListScreen","removeTask","OverrideSetScreen","useSetTaskOverride","setOverride","useClearTaskOverride","clearOverrides","clear","placeholder","Touch","TouchableOpacity","PlanDayTask","view","chroma","stringToColor","luminance","saturate","brighten","hex","Transit","Body1","PlanDay","Scroll","Horizontal","FlexDateSelector","DateSelector","PlanScreen","setStart","setEnd","runPlanning","entries","MoreStackNavigator","createNativeStackNavigator","MoreStack","Navigator","Screen","component","MainTabsNvaigator","createBottomTabNavigator","MainTabs","theme","useTheme","screenOptions","tabBarActiveTintColor","colors","primary","headerShown","tabBarLabel","tabBarIcon","focused","color","RootNavigator","createStackNavigator","Root","animationEnabled","Group","presentation","Router","baseTheme","DefaultTheme","navigationTheme","background","shade","card","text","NavigationContainer","registerRootComponent","usableTime","StatusBar"],"mappings":"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","file":"static/js/app.553d4ac7.chunk.js","sourcesContent":["import { createContext } from \"react\"\nimport { Appointment } from \"../data\"\nimport { Day } from \"../day\"\n\nenum AppointmentsStatus {\n  unavailable = 'unavailable',\n  unapproved = 'unapproved',\n  rejected = 'rejected',\n  approved = 'approved',\n}\n\ntype AppointmentsContextUnavailable = {\n  status: AppointmentsStatus.unavailable | AppointmentsStatus.rejected;\n}\n\ntype AppointmentsContextUnapprovedValue = {\n  status: AppointmentsStatus.unapproved;\n  request: () => Promise<void>;\n}\n\ntype AppointmentsContextApproved = {\n  status: AppointmentsStatus.approved;\n  getDay: (day: Day) => Promise<Appointment[]>\n}\n\ntype AppointmentsContextValue = AppointmentsContextUnavailable\n  | AppointmentsContextUnapprovedValue\n  | AppointmentsContextApproved;\n\nconst AppointmentsContext = createContext<AppointmentsContextValue>(undefined as any);\n\nexport type {\n  AppointmentsContextValue,\n};\nexport { AppointmentsContext, AppointmentsStatus };\n","import { useCallback, useEffect, useMemo, useState } from \"react\"\n\ntype AsyncCallbackOutput<TArgs extends any[], TResult> = [\n  (...args: TArgs) => Promise<TResult>,\n  {\n    loading: boolean;\n    error?: any;\n    result?: TResult;\n    args?: TArgs;\n  }\n];\n\ntype AsyncOutput<TResult> = [\n  TResult | undefined,\n  {\n    loading: boolean;\n    error?: any;\n    rerun: () => Promise<TResult>;\n  }\n]\n\nconst useAsyncCallback = <\n  TArgs extends any[],\n  TResult,\n>(fn: (...args: TArgs) => Promise<TResult>, deps: any[]): AsyncCallbackOutput<TArgs, TResult> => {\n  const [result, setResult] = useState<TResult>();\n  const [prevArgs, setPrevArgs] = useState<TArgs>();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<any>();\n\n  const action = useCallback(fn, deps);\n  \n  const invoke = useCallback(\n    async (...args: TArgs) => {\n      setLoading(true);\n      setError(false);\n      setPrevArgs(args);\n      try {\n        const output = await action(...args);\n        setResult(output);\n        return output;\n      } catch (err) {\n        setResult(undefined);\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [setLoading, setError, setResult, action, ...deps],\n  );\n\n  const options = useMemo(\n    () => {\n      const output: AsyncCallbackOutput<TArgs, TResult> = [\n        invoke,\n        {\n          result,\n          loading,\n          error,\n          args: prevArgs,\n        }\n      ];\n      return output;\n    },\n    [invoke, result, loading, error, prevArgs, ...deps],\n  );\n\n  return options;\n};\n\nconst useAsync = <TResult>(fn: () => Promise<TResult>, deps: any[]): AsyncOutput<TResult> => {\n  const [invoke, options] = useAsyncCallback(fn, deps);\n  useEffect(\n    () => {\n      invoke();\n    },\n    [invoke],\n  );\n\n  const localOptions = useMemo(\n    () => ({\n      loading: options.loading,\n      error: options.error,\n      rerun: invoke,\n    }),\n    [invoke, options.loading, options.error],\n  );\n\n  return [\n    options.result,\n      localOptions,\n  ]\n};\n\nexport type { AsyncCallbackOutput };\nexport { useAsync, useAsyncCallback };\n","import { Day } from \"../day\"\n\nexport enum TaskType {\n  appointment = 'appointment',\n  goal = 'goal',\n  routine = 'routine',\n}\n\nexport type Time = {\n  hour: number;\n  minute: number;\n}\n\nexport type UserLocation = {\n  id: string;\n  title: string;\n  position: {\n    longitute: number;\n    latitude: number;\n  };\n}\n\nexport type TaskBase = {\n  type: TaskType;\n  id: string;\n  title: string;\n  locations?: UserLocation[];\n  required: boolean;\n  priority?: number;\n  startTime: {\n    min: Time;\n    max: Time;\n  };\n  duration: number;\n}\n\nexport type Appointment = TaskBase & {\n  type: TaskType.appointment;\n  calendarId: string;\n}\n\nexport type Goal = TaskBase & {\n  type: TaskType.goal;\n  completed: boolean;\n  deadline?: Day;\n  startDate?: Day;\n  days: boolean[];\n}\n\nexport type Routine = TaskBase & {\n  type: TaskType.routine;\n  days: boolean[];\n}\n\nexport type Task = Appointment | Goal | Routine;\n","import { Time } from \"./types\";\n\nconst equal = (a: Time, b: Time) => {\n  return a.hour == b.hour && a.minute === b.minute;\n}\n\nconst stringToTime = (input: string) => {\n  const [hourPart, minutePart] = input.split(':').map(a => a.trim()).filter(Boolean);\n  const hour = parseInt(hourPart);\n  const minute = parseInt(minutePart || '0');\n\n  if (\n    !Number.isInteger(hour)\n    || !Number.isInteger(minute)\n    || Number.isNaN(hour)\n    || Number.isNaN(minute)\n  ) {\n    return undefined;\n  }\n\n  const result: Time = {\n    hour,\n    minute,\n  };\n\n  return result;\n};\n\nconst largerThan = (a: Time, b: Time) => {\n  return timeToMinutes(a) > timeToMinutes(b);\n}\n\nconst max = (a: Time, b: Time) => largerThan(a, b) ? a : b;\nconst min = (a: Time, b: Time) => largerThan(a, b) ? b : a;\n\nconst timeToString = (input: Time) => `${input.hour}:${input.minute}`;\n\nconst timeToMinutes = (time: Time) => time.hour * 60 + time.minute;\n\nconst minutesToTime = (minutes: number): Time => {\n  const hour = Math.floor(minutes / 60);\n  const minute = minutes % 60;\n  return { hour, minute };\n}\n\nconst timeToDate = (time: Time) => {\n  return new Date(0, 0, 0, time.hour, time.minute);\n}\n\nconst dateToTime = (date: Date) => {\n  return {\n    hour: date.getHours(),\n    minute: date.getMinutes(),\n  };\n}\n\nconst add = (a: Time, b: Time | number) => {\n  const toAdd = typeof b === 'number' ? b : b.hour * 60 + b.minute\n  const current = a.hour * 60 + a.minute + toAdd;\n  return minutesToTime(current);\n}\n\nconst timeUtils = {\n  timeToString,\n  stringToTime,\n  equal,\n  largerThan,\n  timeToMinutes,\n  timeToDate,\n  dateToTime,\n  max,\n  add,\n};\n\nexport { timeUtils };\n","import { createContext } from \"react\";\nimport { Day } from \".\";\n\ntype DateContextValue = {\n  date: Day;\n  setDate: (date: Day) => void;\n}\n\nconst DateContext = createContext<DateContextValue>(undefined as any);\n\nexport type { DateContextValue };\nexport { DateContext }\n","import { Day } from \"./day\";\n\nconst today = () => {\n  return dateToDay(new Date());\n}\n\nconst dayToDate = (day: Day) => {\n  return new Date(day.year, day.month - 1, day.date, 0, 0, 0, 0);\n}\n\nconst dateToDay = (input: Date) => {\n  const year = input.getFullYear();\n  const month = input.getMonth() + 1;\n  const date = input.getDate();\n  const day: Day = { year, month, date };\n  return day;\n}\n\nconst toId = (day: Day) => {\n  return `${day.year.toString().padStart(4, '0')}-${day.month.toString().padStart(2, '0')}-${day.date.toString().padStart(2, '0')}`;\n}\n\nconst dayUtils = {\n  today,\n  dateToDay,\n  dayToDate,\n  toId,\n};\n\nexport { dayUtils };\n","import { ReactNode, useState } from \"react\";\nimport { DateContext } from \"./context\";\nimport { dayUtils } from \"./utils\";\n\ntype DateProviderProps = {\n  children: ReactNode;\n};\n\nconst DateProvider: React.FC<DateProviderProps> = ({ children }) => {\n  const [date, setDate] = useState(dayUtils.today());\n\n  return (\n    <DateContext.Provider value={{ date, setDate }}>\n      {children}\n    </DateContext.Provider>\n  );\n}\n\nexport type { DateProviderProps };\nexport { DateProvider };\n","import { useContext } from \"react\"\nimport { DateContext } from \"./context\"\n\nexport const useDate = () => {\n  const { date } = useContext(DateContext);\n  return date;\n}\n\nexport const useSetDate = () => {\n  const { setDate } = useContext(DateContext);\n  return setDate;\n}\n","import { Appointment, TaskType, timeUtils } from \"#/features/data\";\nimport { Day, dayUtils } from \"#/features/day\";\nimport { set } from \"date-fns\";\nimport { EntityTypes, getCalendarsAsync, getEventsAsync, requestCalendarPermissionsAsync } from \"expo-calendar\";\nimport { Platform } from \"react-native\";\nimport { IntegrationProvider } from \"./provider\";\n\nclass NativeIntegtration implements IntegrationProvider {\n  getAllCalendars = async () => {\n    let calendars = await getCalendarsAsync(EntityTypes.EVENT);\n    return calendars;\n  };\n\n  public setup = async () => {\n    if (Platform.OS !== 'ios') {\n      return false;\n    }\n    const { status } = await requestCalendarPermissionsAsync(); \n    if (status !== 'granted') {\n      return false;\n    }\n    return true;\n  }\n\n  public getDay = async (day: Day) => {\n    const selectedCalendars = await this.getAllCalendars();\n    const start = dayUtils.dayToDate(day)\n    const end = set(start, {\n      hours: 24,\n      minutes: 0,\n      seconds: 0,\n      milliseconds: 0,\n    });\n    const events = await getEventsAsync(selectedCalendars.map(c => c.id), start, end!)\n    return events.filter(a => !a.allDay).map<Appointment>(e => {\n      const startTime = timeUtils.dateToTime(new Date(e.startDate));\n      const endTime = timeUtils.dateToTime(new Date(e.endDate));\n      const duration = timeUtils.timeToMinutes(endTime) - timeUtils.timeToMinutes(startTime);\n      return {\n        id: e.id,\n        type: TaskType.appointment,\n        calendarId: e.calendarId,\n        title: e.title,\n        required: true,\n        startTime: {\n          min: startTime,\n          max: startTime,\n        },\n        duration,\n      }\n    });\n  }\n}\n\nexport { NativeIntegtration };\n","import { useAsync } from \"#/features/async\";\nimport { ReactNode, useState } from \"react\"\nimport { Platform } from \"react-native\";\nimport { AppointmentsContext, AppointmentsContextValue, AppointmentsStatus } from './context';\nimport { NativeIntegtration } from \"./providers/native\";\nimport { IntegrationProvider } from \"./providers/provider\";\n\ntype AppointmentsProviderProps = {\n  children: ReactNode;\n};\n\nconst AppointmentsProvider: React.FC<AppointmentsProviderProps> = ({\n  children,\n}) => {\n  const [provider, setProvider] = useState<IntegrationProvider>();\n  const [value] = useAsync<AppointmentsContextValue>(\n    async () => {\n      if (Platform.OS !== 'ios') {\n        return { status: AppointmentsStatus.unavailable };\n      }\n      const iosProvider = new NativeIntegtration();\n      const setupSuccess = await iosProvider.setup();\n      if (!setupSuccess) {\n        return { status: AppointmentsStatus.unavailable };\n      }\n      setProvider(iosProvider);\n      return {\n        status: AppointmentsStatus.approved,\n        getDay: iosProvider.getDay,\n      };\n    },\n    [],\n  );\n\n  if (!value) {\n    return <></>\n  }\n\n  return (\n    <AppointmentsContext.Provider value={value}>\n      {children}\n    </AppointmentsContext.Provider>\n  );\n}\n\nexport type { AppointmentsProviderProps };\nexport { AppointmentsProvider };\n","import { useAsync, useAsyncCallback } from \"#/features/async\";\nimport AsyncStorageLib from \"@react-native-async-storage/async-storage\";\nimport { createContext, ReactNode, useState } from \"react\"\n\ntype DataContextOptions<T> = {\n  createDefault: () => T;\n  deserialize?: (item: T) => T;\n};\n\ntype DataContextProviderProps = {\n  storageKey: string;\n  children: ReactNode;\n};\n\nfunction createDataContext<T extends {[name: string]: any}>({\n  createDefault,\n  deserialize = a => a,\n}: DataContextOptions<T>) {\n  const Context = createContext<{\n    data: T;\n    setData: (data: T | ((current: T) => T)) => Promise<void>;\n  }>(undefined as any);\n\n  const Provider: React.FC<DataContextProviderProps> = ({\n    storageKey: key,\n    children,\n  }) => {\n    const [current, setCurrent] = useState<T>();\n\n    const [setData] = useAsyncCallback(\n      async (input: T | ((current: T) => T)) => {\n        let next = typeof input === 'function'\n          ? input(current!)\n          : input;\n        setCurrent(next);\n        await AsyncStorageLib.setItem(key, JSON.stringify(next));\n      },\n      [key, current, setCurrent],\n    );\n\n    useAsync(\n      async () => {\n        const raw = await AsyncStorageLib.getItem(key);\n        const next = raw ? deserialize(JSON.parse(raw)) : createDefault();\n        setCurrent(next);\n      },\n      [key, setCurrent],\n    )\n\n    if (!current) {\n      return <></>\n    }\n\n    return (\n      <Context.Provider value={{ data: current, setData }}>\n        {children}\n      </Context.Provider>\n    )\n  };\n\n  return { Context, Provider };\n}\n\nexport { createDataContext };\n","import { createDataContext } from \"#/utils/data-context\";\nimport { Goal } from \"../data\";\n\nconst {\n  Context: GoalsContext,\n  Provider: GoalsProvider,\n}= createDataContext<{[id: string]: Goal}>({\n  createDefault: () => ({}),\n})\n\nexport { GoalsContext, GoalsProvider };\n","import { Time, UserLocation } from \"../data\";\nimport { createContext } from \"react\"\n\ntype Transition = {\n  time: number;\n  usableTime: number;\n  to: UserLocation;\n  from: UserLocation;\n};\n\ntype GetTransition = (\n  from: UserLocation,\n  to: UserLocation,\n  time: Time,\n) => Promise<Transition>;\n\ntype LocationContextValue = {\n  locations: {\n    [id: string]: UserLocation;\n  };\n  set: (location: UserLocation) => any;\n  remove: (id: string) => any;\n  lookup?: (address: string) => UserLocation[];\n  getTransition: GetTransition;\n}\n\nconst LocationContext = createContext<LocationContextValue>(undefined as any);\n\nexport type { LocationContextValue, GetTransition, Transition };\nexport { LocationContext };\n","import { useAsync, useAsyncCallback } from \"#/features/async\";\nimport { GetTransition } from \"./context\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { ReactNode, useState } from \"react\";\nimport { LocationContext } from \"./context\";\nimport { UserLocation } from \"../data\";\n\ntype LocationProviderProps = {\n  children: ReactNode;\n  lookup: (address: string) => UserLocation[];\n  getTransition: GetTransition;\n}\n\nconst LOCATION_STORAGE_KEY = 'locations';\n\nconst LocationProvider: React.FC<LocationProviderProps> = ({\n  children,\n  lookup,\n  getTransition,\n}) => {\n  const [locations, setLocations] = useState<{[id: string]: UserLocation}>({});\n\n  useAsync(\n    async () => {\n      const raw = await AsyncStorage.getItem(LOCATION_STORAGE_KEY);\n      if (raw) {\n        setLocations(JSON.parse(raw));\n      }\n    },\n    [],\n  );\n\n  const [set] = useAsyncCallback(\n    async (location: UserLocation) => {\n      const index = {\n        ...locations,\n        [location.id]: location,\n      }\n      setLocations(index);\n      await AsyncStorage.setItem(LOCATION_STORAGE_KEY, JSON.stringify(index));\n    },\n    [setLocations, locations],\n  )\n\n  const [remove] = useAsyncCallback(\n    async (id: string) => {\n      const index = {\n        ...locations,\n      }\n      delete index[id];\n      setLocations(index);\n      await AsyncStorage.setItem(LOCATION_STORAGE_KEY, JSON.stringify(index));\n    },\n    [setLocations, locations],\n  );\n\n  return (\n    <LocationContext.Provider\n      value={{\n        locations,\n        set,\n        remove,\n        lookup,\n        getTransition,\n      }}\n    >\n      {children}\n    </LocationContext.Provider>\n  )\n}\n\nexport type { LocationProviderProps };\nexport { LocationProvider };\n","import { useAsync } from \"#/features/async\";\nimport { useContext, useMemo } from \"react\"\nimport { requestForegroundPermissionsAsync, getCurrentPositionAsync } from 'expo-location';\nimport { LocationContext } from \"./context\"\nimport { UserLocation } from \"../data\";\nimport { getDistanceFromLatLonInKm } from \"./utils\";\n\nexport const useLocations = () => {\n  const { locations } = useContext(LocationContext);\n  const result = useMemo(() => Object.values(locations), [locations]);\n  return result;\n}\n\nexport const useSetLocation = () => {\n  const { set } = useContext(LocationContext);\n  return set;\n}\n\nexport const useRemoveLocation = () => {\n  const { remove } = useContext(LocationContext);\n  return remove;\n}\n\nexport const useGetTransition = () => {\n  const { getTransition } = useContext(LocationContext);\n  return getTransition;\n}\n\nexport const useLookup = () => {\n  const { lookup } = useContext(LocationContext);\n  return lookup;\n}\n\nexport const useCurrentLocation = (proximity: number = 0.5) => {\n  const { locations } = useContext(LocationContext);\n  const result = useAsync<UserLocation | undefined>(\n    async () => {\n      let { status } = await requestForegroundPermissionsAsync();\n      if (status !== 'granted') {\n        return undefined;\n      }\n      let position = await getCurrentPositionAsync({});\n      const withDistance = Object.values(locations).map((location) => {\n        if (!location.position) {\n          return;\n        }\n        const distance = getDistanceFromLatLonInKm(\n          position.coords.latitude,\n          position.coords.longitude,\n          location.position.latitude,\n          location.position.longitute,\n        )\n        return {\n          distance,\n          location,\n        }\n      }).filter(Boolean).sort((a, b) => a!.distance - b!.distance)\n      const current = withDistance.find(d => d!.distance < proximity);\n      if (!current) {\n        return {\n          id: `${position.coords.longitude} ${position.coords.latitude}`,\n          title: 'Unknown',\n          position: {\n            latitude: position.coords.latitude,\n            longitute: position.coords.longitude,\n          },\n        };\n      }\n      return current.location;\n    },\n    [],\n  );\n  return result;\n}\n","import { createContext, SetStateAction } from \"react\";\nimport { Time, UserLocation } from \"../data\";\nimport { Day } from \"../day\";\n\ntype Override = {\n  locations?: UserLocation[] | null;\n  startMin?: Time;\n  startMax?: Time;\n  duration?: number;\n  required?: boolean;\n  priority?: number;\n  enabled?: boolean;\n}\n\ntype OverrideIndex = {\n  startTime?: Time;\n  tasks: {\n    [id: string]: Override;\n  };\n};\n\ntype OverrideContextValue = {\n  overrides: OverrideIndex;\n  get: (date: Day) => Promise<OverrideIndex>;\n  set: React.Dispatch<SetStateAction<OverrideIndex>>;\n}\nconst OverrideContext = createContext<OverrideContextValue>(undefined as any);\n\nexport type { Override, OverrideIndex, OverrideContextValue };\nexport { OverrideContext };\n","import AsyncStorageLib from \"@react-native-async-storage/async-storage\";\nimport React, { ReactNode, SetStateAction, useCallback, useState } from \"react\";\nimport { useAsync } from \"../async\";\nimport { Day, useDate, dayUtils } from \"../day\";\nimport { Override, OverrideContext, OverrideIndex } from \"./context\";\n\ntype OverrideProviderProps = {\n  children: ReactNode;\n}\n\nconst StorageKey = 'overrides';\n\nconst OverrideProvider: React.FC<OverrideProviderProps> = ({ children }) => {\n  const currentDate = useDate();\n  const [overrides, setOverrides] = useState<OverrideIndex>();\n\n  const get = useCallback(\n    async (date: Day): Promise<OverrideIndex> => {\n      const raw = await AsyncStorageLib.getItem(`${StorageKey}_${dayUtils.toId(date)}`);\n      if (!raw) {\n        return { tasks: {} };\n      }\n      return JSON.parse(raw);\n    },\n    [],\n  );\n\n  const set = useCallback(\n    async (override: SetStateAction<OverrideIndex>) => {\n      const next = typeof override === 'function' ? override(overrides!) : overrides;\n      setOverrides(next);\n      await AsyncStorageLib.setItem(\n        `${StorageKey}_${dayUtils.toId(currentDate)}`,\n        JSON.stringify(next),\n      );\n    },\n    [currentDate, overrides],\n  );\n\n  useAsync(\n    async () => {\n      setOverrides(await get(currentDate));\n    },\n    [currentDate, setOverrides],\n  );\n\n  if (!overrides) {\n    return <></>\n  }\n\n  return (\n    <OverrideContext.Provider value={{ overrides, get, set }}>\n      {children}\n    </OverrideContext.Provider>\n  );\n}\n\nexport type { OverrideProviderProps };\nexport { OverrideProvider };\n","import { UserLocation } from \"#/types/location\";\nimport { Task } from \"#/types/task\";\n\nexport const locationEqual = (a: UserLocation, b: UserLocation) => {\n  if (a === b) {\n    return true;\n  }\n  // if (a.location === b.location) {\n  //   return true;\n  // }\n  // if (a.location && b.location && a.location.latitude === b.location.latitude && a.location.longitute === b.location.longitute) {\n  //   return true;\n  // }\n  if (a.title === b.title) {\n    return true;\n  }\n  return false;\n}\n\nexport const listContainLocation = (list: UserLocation[], target: UserLocation) => {\n  return !!list.find(l => locationEqual(l, target));\n}\n\nexport const getRemainingLocations = (tasks: Task[], current: UserLocation) => {\n  const result: UserLocation[] = [];\n  tasks.forEach((task) => {\n    if (!task.locations) {\n      return;\n    }\n    for (let location of task.locations) {\n      if (!listContainLocation(result, location) && !locationEqual(current, location)) {\n        result.push(location)\n      }\n    }\n  })\n  return result;\n};\n\n","import { Task, Time, timeUtils } from '#/features/data';\nimport { Transition } from '#/features/location';\nimport { Context, GraphNode } from '../types';\nimport { getRemainingLocations, listContainLocation } from './utils';\n\nconst DEFAULT_PRIORITY = 50;\n\nconst isDead = (impossible: Task[]) => {\n  const missingRequered = impossible.find(t => t.required);\n  return !!missingRequered;\n}\n\ntype GetImpossibleResult = {\n  remaining: Task[];\n  impossible: Task[];\n}\n\nexport const getImpossible = (\n  tasks: Task[],\n  time: Time,\n) => {\n  const result: GetImpossibleResult = {\n    remaining: [],\n    impossible: [],\n  }\n\n  for (let task of tasks) {\n    if (timeUtils.largerThan(time, task.startTime.max)) {\n      result.impossible.push(task);\n    } else {\n      result.remaining.push(task);\n    }\n  };\n\n  return result;\n}\n\ntype CalculateScoreOptions = {\n  tasks?: Task[];\n  transition?: Transition;\n  impossible: Task[];\n}\n\nconst calculateScore = ({\n  tasks,\n  transition,\n  impossible,\n}: CalculateScoreOptions) => {\n  let score = 0;\n\n  tasks?.forEach((task) => {\n    score += (task.priority || DEFAULT_PRIORITY) * 10;\n    impossible.forEach((task) => {\n      if (task.required) {\n        score -= 10000 + (1 * (task.priority || DEFAULT_PRIORITY));\n      } else {\n        score -= 100 + (1 * (task.priority || DEFAULT_PRIORITY));\n      }\n    });\n  });\n  if (transition) {\n    const minutes = transition.time;\n    score -= 10 + (1 * minutes);\n  }\n  return score;\n}\nconst getNext = async (\n  currentNode: GraphNode,\n  context: Context,\n): Promise<GraphNode[]> => {\n  const nextNodes: GraphNode[] = [];\n  if (!currentNode.transition) {\n    const remainingLocations = getRemainingLocations(currentNode.remainingTasks, currentNode.location);\n    await Promise.all(remainingLocations.map(async(location) => {\n      const transition = await context.getTransition(currentNode.location, location, currentNode.time.end);\n      const endTime = timeUtils.add(currentNode.time.end, transition.time);\n      const { remaining, impossible } = getImpossible(currentNode.remainingTasks, endTime);\n      const score = calculateScore({\n        transition, \n        impossible,\n      });\n      nextNodes.push({\n        parent: currentNode,\n        location: transition.to,\n        remainingTasks: remaining,\n        transition,\n        impossibeTasks: [\n          ...impossible,\n          ...currentNode.impossibeTasks,\n        ],\n        score: currentNode.score + score,\n        status: {\n          completed: false,\n          dead: false, // TODO: fix isDead(impossible),\n        },\n        time: {\n          start: currentNode.time.end,\n          end: endTime,\n        },\n      })\n    }));\n  }\n  const possibleTasks = currentNode.remainingTasks.filter(task => !task.locations || listContainLocation(task.locations, currentNode.location))\n  await Promise.all(possibleTasks.map(async (orgTask) => {\n    const task = {...orgTask};\n    let startTime = \n      timeUtils.max(\n        currentNode.time.end,\n        task.startTime.min,\n      );\n    const parentRemainging = currentNode.remainingTasks.filter(t => t !== orgTask);\n    let endTime = timeUtils.add(startTime, task.duration);\n    const { remaining, impossible } = getImpossible(parentRemainging, endTime);\n    const score = calculateScore({\n      tasks: [task], \n      impossible,\n    });\n    nextNodes.push({\n      parent: currentNode,\n      location: currentNode.location,\n      task,\n      remainingTasks: remaining,\n      impossibeTasks: [\n        ...impossible,\n        ...currentNode.impossibeTasks,\n      ],\n      score: currentNode.score + score,\n      status: {\n        completed: remaining.length === 0,\n        dead: isDead(impossible),\n      },\n      time: {\n        start: startTime,\n        end: endTime,\n      },\n    })\n  }));\n  return nextNodes;\n};\n\nexport { getNext };\n","import { Task, Time, UserLocation } from \"#/features/data\";\nimport { Context, GraphNode } from \"../types\";\nimport { getImpossible, getNext } from \"./get-next\";\n\nenum Strategies {\n  all = 'all',\n  allValid = 'all-valid',\n  firstValid = 'first-valid',\n  firstComplet = 'first-complete',\n}\ntype RunningStatus = {\n  current: 'running';\n  nodes: number;\n  start: Date;\n  strategy: Strategies,\n  cancel: () => void;\n}\n\ntype CompletedStatus = {\n  current: 'completed';\n  start: Date;\n  end: Date;\n  nodes: number;\n  strategy: Strategies,\n}\n\ntype Status = RunningStatus | CompletedStatus;\n\ntype BuildGraphOptions = {\n  location: UserLocation;\n  time: Time;\n  tasks: Task[];\n  context: Context;\n  strategy?: Strategies;\n  batchSize?: number;\n  sleepTime?: number;\n  callback?: (status: Status) => void;\n};\n\nconst sleep = (time: number) => new Promise(resolve => setTimeout(resolve, time));\n\nconst fil = <T>(\n  fn: ((item: T) => boolean)[],\n  input: T[],\n): T[][] => {\n  const output: T[][] = new Array(fn.length).fill(undefined).map(() => []);\n  for (let i = 0; i < input.length; i++) {\n    for (let b = 0; b < fn.length; b++) {\n      if (fn[b](input[i])) {\n        output[b].push(input[i]);\n        break;\n      }\n    }\n  }\n  return output;\n};\n\nconst buildGraph = async ({\n  location,\n  time,\n  tasks,\n  context,\n  strategy = Strategies.allValid,\n  callback,\n  batchSize = 1000,\n  sleepTime = 10,\n}: BuildGraphOptions) => {\n  const start = new Date();\n  let nodeCount = 0;\n  let running = true;\n  const { remaining, impossible } = getImpossible(tasks, time);\n  let leafList: GraphNode[] = [{\n    location,\n    time: {\n      end: time,\n      start: time,\n    },\n    score: 0,\n    remainingTasks: remaining,\n    impossibeTasks: impossible,\n    status: {\n      dead: false,\n      completed: false,\n    },\n  }];\n  const completedList: GraphNode[] = [];\n  const deadList: GraphNode[] = [];\n\n  const complete = (nodes: GraphNode[]) => {\n    if (callback) {\n      callback({\n        current: 'completed',\n        nodes: nodeCount,\n        start,\n        end: new Date(),\n        strategy,\n      });\n    }\n    return nodes.sort((a, b) => b.score - a.score);\n  }\n\n  while (true) {\n    nodeCount++;\n    if (!running) {\n      return [];\n    }\n    if (\n      leafList.length === 0\n      && completedList.length === 0\n      && strategy !== Strategies.all\n    ) {\n      strategy = Strategies.all;\n      leafList.push(...deadList);\n    }\n    const node = leafList.pop();\n    if (!node) {\n      break;\n    }\n    if (nodeCount % batchSize === 0) {\n      if (callback) {\n        callback({\n          current: 'running',\n          nodes: nodeCount,\n          strategy,\n          start,\n          cancel: () => {\n            running = false;\n          }\n        })\n      }\n      await sleep(sleepTime);\n    }\n    const next = await getNext(node, context); \n    const [alive, completed, dead] = fil([\n      n => (strategy === Strategies.all || !n.status.dead) && !n.status.completed,\n      n => !!n.status.completed && (strategy === Strategies.all || !n.status.dead),\n      n => n.status.dead,\n    ], next);\n    leafList.push(...alive);\n    if (strategy === Strategies.firstValid && completed.length > 0) {\n      return complete(completed);\n    }\n    if (completed.length > 0) {\n      completedList.push(...completed)\n    }\n    if (strategy === Strategies.firstComplet) {\n      const fullComplete = completed.find(c => c.impossibeTasks.length === 0);\n      if (fullComplete) {\n        return complete([fullComplete]);\n      }\n    }\n    if (strategy !== Strategies.all) {\n      deadList.push(...dead);\n    }\n  }\n\n  return complete(completedList);\n}\n\nexport type { Status, BuildGraphOptions };\nexport { buildGraph, Strategies };\n","import { createDataContext } from '#/utils/data-context';\nimport { Time } from '../data';\nimport { Strategies } from \"./algorithm/build-graph\";\n\ntype PlannerOptions = {\n  strategy: Strategies;\n  startTime: Time;\n}\n\nconst {\n  Context: PlannerContext,\n  Provider: PlannerProvider,\n} = createDataContext<PlannerOptions>({\n  createDefault: () => ({\n    startTime: { hour: 7, minute: 0 },\n    strategy: Strategies.firstComplet,\n  }),\n});\n\nexport type { PlannerOptions };\nexport { PlannerContext, PlannerProvider };\n","import { createDataContext } from \"#/utils/data-context\";\nimport { Routine } from \"../data\";\n\nconst {\n  Context: RoutinesContext,\n  Provider: RoutinesProvider,\n}= createDataContext<{[id: string]: Routine}>({\n  createDefault: () => ({}),\n})\n\nexport { RoutinesContext, RoutinesProvider };\n","import { useCallback, useContext, useMemo } from \"react\"\nimport { Routine } from \"../data\";\nimport { RoutinesContext } from \"./context\"\n\nexport const useRoutines = () => {\n  const { data } = useContext(RoutinesContext);\n  const current = useMemo(\n    () => Object.values(data),\n    [data],\n  )\n  return current;\n};\n\nexport const useSetRoutine = () => {\n  const { setData } = useContext(RoutinesContext);\n  const set = useCallback(\n    (routine: Routine) => setData(current => ({\n      ...current,\n      [routine.id]: routine, \n    })),\n    [setData],\n  );\n\n  return set;\n}\n\nexport const useRemoveRoutine = () => {\n  const { setData } = useContext(RoutinesContext);\n  const removeRoutine = useCallback(\n    (id: string) => {\n      setData(current => {\n        const next = {...current};\n        delete next[id];\n        return next;\n      })\n    },\n    [setData],\n  );\n\n  return removeRoutine;\n}\n","import { useCallback, useContext, useMemo } from \"react\"\nimport { Goal } from \"../data\";\nimport { GoalsContext } from \"./context\"\n\nexport const useGoals = () => {\n  const { data } = useContext(GoalsContext);\n  const current = useMemo(\n    () => Object.values(data),\n    [data],\n  )\n  return current;\n};\n\nexport const useSetGoals = () => {\n  const { setData } = useContext(GoalsContext);\n  const set = useCallback(\n    (goal: Goal) => setData(current => ({\n      ...current,\n      [goal.id]: goal, \n    })),\n    [setData],\n  );\n\n  return set;\n}\n\nexport const useRemoveGoal = () => {\n  const { setData } = useContext(GoalsContext);\n  const removeRoutine = useCallback(\n    (id: string) => {\n      setData(current => {\n        const next = {...current};\n        delete next[id];\n        return next;\n      })\n    },\n    [setData],\n  );\n\n  return removeRoutine;\n}\n","import { timeUtils } from \"#/features/data\";\nimport { GraphNode, PlannedEntry } from \"../types\";\n\nconst constructDay = (node: GraphNode) => {\n  let current: GraphNode | undefined = node;\n  const plans: PlannedEntry[] = [];\n\n  while(current) {\n    if (current.task) {\n      plans.push({\n        type: 'task',\n        name: current.task?.title || 'start',\n        start: timeUtils.add(current.time.start, (current.transition?.time || 0)),\n        end: current.time.end,\n        score: current.score,\n      })\n    }\n    if (current.transition) {\n      plans.push({\n        type: 'transition',\n        start: current.time.start,\n        end: timeUtils.add(current.time.start, current.transition.time),\n        from: current.transition.from,\n        to: current.transition.to,\n      })\n    }\n    current = current.parent;\n  }\n\n  return plans.reverse();\n}\n\nexport { constructDay };\n","import { buildGraph, Status, Strategies } from \"./algorithm/build-graph\";\nimport { useContext, useMemo, useState } from \"react\";\nimport { add } from 'date-fns';\nimport { PlannerContext } from \"./context\";\nimport { Task, Time, UserLocation } from \"../data\";\nimport { useRoutines } from \"../routines\";\nimport { useGoals } from \"../goals/hooks\";\nimport { useAsyncCallback } from \"../async\";\nimport { Day, dayUtils } from \"../day\";\nimport { useGetOverride } from \"../overrides\";\nimport { useGetAppointments } from \"../appointments\";\nimport { useGetTransition } from \"../location\";\nimport { PlannedEntry } from \"./types\";\nimport { constructDay } from \"./algorithm/construct-day\";\n\nexport type PreparePlanOptions = {\n  start: Day;\n  end: Day;\n}\n\nexport type PlanOptions = PreparePlanOptions & {\n  location: UserLocation;\n}\n\nexport type PlanResultDay = {\n  day: Day;\n  start: Time;\n} & ({\n  status: 'waiting',\n} | {\n  status: 'running',\n  nodes: number;\n  strategy: Strategies;\n} | {\n  status: 'done';\n  nodes: number;\n  strategy: Strategies;\n  plan: PlannedEntry[];\n  impossible: Task[];\n});\n\nexport type PlanResult = {\n  impossible: Task[];\n  days: {\n    [day: string]: PlanResultDay;\n  }\n}\n\nconst getDays = (start: Day, end: Day): Day[] => {\n  const result: Day[] = [];\n  let currentDate = dayUtils.dayToDate(start);\n  const stopDate = dayUtils.dayToDate(end);\n  while (currentDate <= stopDate) {\n    result.push(dayUtils.dateToDay(currentDate));\n    currentDate = add(currentDate, {\n      days: 1,\n    });\n  }\n  return result;\n}\n\nconst firstValue = <T>(...args: (T | undefined)[]): T => {\n  for (let arg of args) {\n    if (typeof arg !== 'undefined') {\n      return arg;\n    }\n  }\n  return undefined as unknown as T;\n}\n\nexport const useOptions = () => {\n  const { data } = useContext(PlannerContext);\n  return data;\n}\n\nexport const useSetOptions = () => {\n  const { setData } = useContext(PlannerContext);\n  return setData;\n}\n\nconst usePreparePlan = () => {\n  const routines = useRoutines();\n  const goals = useGoals();\n  const getOverrides = useGetOverride();\n  const [getAppontments] = useGetAppointments();\n\n  const preparePlan = useAsyncCallback(\n    async ({ start, end }: PreparePlanOptions) => {\n      const days = await Promise.all(getDays(start, end).map(async (day) => {\n        const overrides = await getOverrides(day);\n        const start: Time = firstValue(overrides.startTime, { hour: 7, minute: 0 });\n        const appointments = await getAppontments(day);\n        const tasks = [...routines, ...appointments].map<Task | undefined>((task) => {\n          const override = overrides.tasks[task.id];\n          if (override?.enabled === false) {\n            return undefined;\n          }\n          const result: Task = {\n            ...task,\n            startTime: {\n              min: firstValue(override?.startMin, task.startTime.min),\n              max: firstValue(override?.startMax, task.startTime.max),\n            },\n            duration: firstValue(override?.duration, task.duration),\n            required: firstValue(override?.required, task.required),\n            locations: firstValue(override?.locations, task.locations) || undefined,\n          }\n          return result;\n        }).filter(Boolean).map(a => a as Exclude<typeof a, undefined>);\n\n        return {\n          day,\n          start,\n          tasks,\n        }\n\n      }));\n      return {\n        goals: [...goals],\n        days,\n      }\n    },\n    [routines, goals, getOverrides, getAppontments],\n  );\n\n  return preparePlan;\n}\n\nexport const usePlanOptions = () => {\n  const { data } = useContext(PlannerContext);\n  return data;\n}\n\nexport const useSetPlanOptions = () => {\n  const { setData } = useContext(PlannerContext);\n  return setData;\n}\n\nexport const usePlan = () => {\n  const [preparePlan] = usePreparePlan();\n  const [result, setResult] = useState<PlanResult | undefined>(undefined);\n  const getTransition = useGetTransition();\n  const options = usePlanOptions();\n  const createPlan = useAsyncCallback(\n    async ({ location, ...prepareOptions}: PlanOptions) => {\n      const prepared = await preparePlan(prepareOptions);\n      let result: PlanResult = {\n        impossible: [],\n        days: prepared.days.reduce((output, current) => ({\n          ...output,\n          [dayUtils.toId(current.day)]: {\n            day: current.day,\n            start: current.start,\n            status: 'waiting',\n          },\n        }), {} as {[name: string]: PlanResultDay})\n      }\n      const update = (next: PlanResult) => {\n        setResult(next);\n        result = next;\n        return next;\n      }\n      for (let day of prepared.days) {\n        const id = dayUtils.toId(day.day);\n        const dayGoal = prepared.goals;\n        const graph = await buildGraph({\n          location,\n          time: day.start,\n          tasks: [...day.tasks, ...dayGoal],\n          strategy: options.strategy,\n          context: {\n            getTransition,\n          },\n          callback: (status) => {\n            update({\n              ...result,\n              days: {\n                ...result.days,\n                [id]: {\n                  day: day.day,\n                  start: day.start,\n                  status: 'running',\n                  nodes: status.nodes,\n                  strategy: status.strategy,\n                }\n              }\n            });\n          }\n        });\n        const [winner] = graph;\n        if (!winner) {\n          continue;\n        }\n        const plan = constructDay(winner);\n        update({\n          ...result,\n          days: {\n            ...result.days,\n            [id]: {\n              ...result.days[id],\n              impossible: winner.impossibeTasks,\n              status: 'done',\n              plan,\n            }\n          }\n        })\n        prepared.goals = prepared.goals.filter((goal) => {\n          if (!dayGoal.find(d => d.id === goal.id)) {\n            return true;\n          }\n          if (!winner.impossibeTasks.find(d => d.id === goal.id)) {\n            return false;\n          }\n          return true;\n        })\n      }\n\n      return update({\n        ...result,\n        impossible: prepared.goals,\n      });\n    },\n    [preparePlan, getTransition, options],\n  );\n  const output = useMemo(\n    () => [\n      createPlan[0],\n      { ...createPlan[1], result },\n    ],\n    [createPlan, result],\n  );\n  return output;\n}\n","import { useContext } from \"react\"\nimport { useAsyncCallback } from \"../async\";\nimport { Time } from \"../data\";\nimport { Override, OverrideContext } from \"./context\"\n\nexport const useOverrides = () => {\n  const { overrides } = useContext(OverrideContext);\n  return overrides;\n}\n\nexport const useSetOverride = () => {\n  const { set } = useContext(OverrideContext);\n  return set;\n}\n\nexport const useGetOverride = () => {\n  const { get } = useContext(OverrideContext);\n  return get;\n}\n\nexport const useSetTaskOverride = () => {\n  const { set } = useContext(OverrideContext);\n  const setTaskOverride = useAsyncCallback(\n    async (id: string, overrides: Override) => {\n      set(current => ({\n        ...current,\n        tasks: {\n          ...current.tasks,\n          [id]: overrides,\n        },\n      }));\n    },\n    [set],\n  );\n  return setTaskOverride;\n}\n\nexport const useClearTaskOverride = () => {\n  const { set } = useContext(OverrideContext);\n  const clearTaskOverride = useAsyncCallback(\n    async (id: string) => {\n      set(current => {\n        const tasks = {...current.tasks};\n        delete tasks[id]\n        return {\n          ...current,\n          tasks,\n        };\n      });\n    },\n    [set],\n  );\n  return clearTaskOverride;\n}\n\nexport const useStartTimeOverride = () => {\n  const { overrides } = useContext(OverrideContext);\n  return overrides.startTime; \n};\n\nexport const useSetStartTimeOverride = () => {\n  const { set } = useContext(OverrideContext);\n  const setStartTime = useAsyncCallback(\n    async (startTime?: Time) => {\n      set(current => ({\n        ...current,\n        startTime,\n      }));\n    },\n    [set],\n  );\n  return setStartTime;\n};\n","import { useAsync, useAsyncCallback } from \"#/features/async\";\nimport { useContext } from \"react\"\nimport { Day, useDate } from \"../day\";\nimport { AppointmentsContext, AppointmentsStatus } from \"./context\"\n\nexport const useAppointmentStatus = () => {\n  const { status } = useContext(AppointmentsContext);\n  return status;\n};\n\nexport const useAppointments = () => {\n  const date = useDate();\n  const context = useContext(AppointmentsContext);\n  const result = useAsync(\n    async () => {\n      if (context.status !== AppointmentsStatus.approved) {\n        return [];\n      }\n      const appointments = await context.getDay(date);\n      return appointments;\n    },\n    [\n      context.status === AppointmentsStatus.approved && context.getDay,\n      date,\n    ],\n  );\n  return result;\n}\n\nexport const useGetAppointments = () => {\n  const context = useContext(AppointmentsContext);\n  const result = useAsyncCallback(\n    async (date: Day) => {\n      if (context.status !== AppointmentsStatus.approved) {\n        return [];\n      }\n      const appointments = await context.getDay(date);\n      return appointments;\n    },\n    [\n      context.status === AppointmentsStatus.approved && context.getDay,\n    ],\n  );\n  return result;\n}\n","import { ReactNode } from \"react\"\nimport { AppointmentsProvider } from \"./appointments\"\nimport { DateProvider } from \"./day\"\nimport { GoalsProvider } from \"./goals/context\"\nimport { GetTransition, LocationProvider } from \"./location\"\nimport { OverrideProvider } from \"./overrides\"\nimport { PlannerProvider } from \"./planner\"\nimport { RoutinesProvider } from \"./routines\"\n\ntype SetupProps = {\n  children: ReactNode;\n  getTransit: GetTransition;\n}\n\nconst Setup: React.FC<SetupProps> = ({\n  children,\n  getTransit,\n}) => {\n  return (\n    <DateProvider>\n      <PlannerProvider storageKey=\"planner\">\n        <LocationProvider getTransition={getTransit} lookup={() => []}>\n          <AppointmentsProvider>\n            <GoalsProvider storageKey=\"goals\">\n              <RoutinesProvider storageKey=\"routines\">\n                <OverrideProvider>\n                  {children}\n                </OverrideProvider>\n              </RoutinesProvider>\n            </GoalsProvider>\n          </AppointmentsProvider>\n        </LocationProvider>\n      </PlannerProvider>\n    </DateProvider>\n  );\n};\n\nexport type { SetupProps };\nexport { Setup };\n","import { useMemo } from \"react\";\nimport { useAppointments } from \"../appointments\";\nimport { useAsyncCallback } from \"../async\";\nimport { Task, TaskType } from \"../data\";\nimport { useGoals, useRemoveGoal, useSetGoals } from \"../goals/hooks\";\nimport { useRemoveRoutine, useRoutines, useSetRoutine } from \"../routines\";\n\nexport const useTasks = (type?: TaskType) => {\n  const [appointments] = useAppointments();\n  const routines = useRoutines();\n  const goals = useGoals();\n\n  const tasks = useMemo<Task[]>(\n    () => {\n      if (!type) {\n        return [...(appointments || []), ...routines, ...goals];\n      }\n      const map = {\n        [TaskType.routine]: routines,\n        [TaskType.appointment]: appointments,\n        [TaskType.goal]: goals,\n      }\n      return map[type] || [];\n    },\n    [appointments, routines, goals, type],\n  );\n\n  return tasks;\n};\n\nexport const useSetTask = () => {\n  const setRoutine = useSetRoutine();\n  const setGoal = useSetGoals();\n\n  const result = useAsyncCallback(\n    async (task: Task) => {\n      if (task.type === TaskType.routine) {\n        await setRoutine(task);\n      } else if (task.type === TaskType.goal) {\n        await setGoal(task);\n      }\n    },\n    [setRoutine, setGoal],\n  );\n  return result;\n};\n\nexport const useRemoveTask = () => {\n  const removeRoutine = useRemoveRoutine();\n  const removeGoal = useRemoveGoal();\n\n  const result = useAsyncCallback(\n    async (task: Task) => {\n      if (task.type === TaskType.routine) {\n        removeRoutine(task.id);\n      } else if (task.type === TaskType.goal) {\n        removeGoal(task.id);\n      }\n    },\n    [removeRoutine, removeGoal],\n  );\n  return result;\n};\n","import { TaskType } from \"#/features/data\";\nimport { useTasks } from \"#/features/tasks\";\nimport { Group } from \"@morten-olsen/ui\"\nimport { RootNavigationProp } from \"#/ui/router\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { useCallback } from \"react\";\n\ntype Props = {\n  type: TaskType;\n}\n\nconst TaskGroup: React.FC<Props> = ({ type }) => {\n  const { navigate } = useNavigation<RootNavigationProp>();\n  const tasks = useTasks(type);\n\n  const add = useCallback(\n    (type: TaskType) => {\n      navigate('add-task', {\n        type,\n      })\n    },\n    [navigate],\n  );\n\n  return (\n    <Group\n      title={type}\n      add={() => add(type)}\n      items={tasks || []}\n      getKey={(task) => task.id}\n      render={(task) => ({\n        title: task.title,\n        onPress: () => {\n          navigate('set-override', { id: task.id });\n        },\n      })}\n    />\n  );\n};\n\nexport { TaskGroup };\n","import { useAppointmentStatus } from \"#/features/appointments\";\nimport { AppointmentsStatus } from \"#/features/appointments/context\";\nimport { TaskType } from \"#/features/data\";\nimport { dayUtils, useDate, useSetDate } from \"#/features/day\";\nimport { useSetStartTimeOverride, useStartTimeOverride } from \"#/features/overrides\";\nimport { CalendarStrip } from \"@morten-olsen/ui/components/date\"\nimport { TimeInput } from \"@morten-olsen/ui/components/form\";\nimport { TaskGroup } from \"#/ui/containers/tasks/group\";\nimport styled from \"styled-components/native\";\n\nconst Wrapper = styled.View`\n  margin-top: 30px;\n  flex: 1;\n`;\n\nconst Content = styled.ScrollView`\n  flex: 1;\n`;\n\nconst DayScreen: React.FC = () => {\n  const date = useDate();\n  const setDate = useSetDate();\n  const appointmentStatus = useAppointmentStatus();\n  const startTimeOverride = useStartTimeOverride();\n  const [setStartTimeOverride] = useSetStartTimeOverride();\n\n  return (\n    <Wrapper>\n      <CalendarStrip\n        selected={dayUtils.dayToDate(date)}\n        onSelect={(date) => setDate(dayUtils.dateToDay(date))}\n      />\n      <Content>\n        <TimeInput\n          key={dayUtils.toId(date)}\n          label=\"Start time\"\n          value={startTimeOverride}\n          onChange={setStartTimeOverride}\n        />\n        {appointmentStatus === AppointmentsStatus.approved && (\n          <TaskGroup type={TaskType.appointment} />\n        )}\n        <TaskGroup type={TaskType.routine} />\n        <TaskGroup type={TaskType.goal} />\n      </Content>\n    </Wrapper>\n  );\n};\n\nexport { DayScreen };\n","import { useAsyncCallback } from \"#/features/async\";\nimport { nanoid } from 'nanoid';\nimport { Task, TaskType, Time, UserLocation } from \"#/features/data\";\nimport { useLocations } from \"#/features/location\";\nimport { useSetTask, useTasks } from \"#/features/tasks\";\nimport { Button, Cell, Group, Popup, Row } from \"@morten-olsen/ui/components/base\"\nimport { Checkbox, TextInput, TimeInput, OptionalSelector } from \"@morten-olsen/ui/components/form\";\nimport { RootNavigationProp, TaskAddScreenRouteProp } from \"#/ui/router\";\nimport { Overline } from \"@morten-olsen/ui/typography\";\nimport { useNavigation, useRoute } from \"@react-navigation/native\";\nimport { useEffect, useState } from \"react\";\nimport styled from \"styled-components/native\";\n\nconst SideBySide = styled.View`\n  flex-direction: row;\n`;\n\nconst dayNames = [\n  'Monday',\n  'Tuesday',\n  'Wednsday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n  'Sunday',\n]\n\nconst days = new Array(7).fill(undefined).map((_, i) => ({\n  id: i,\n  name: dayNames[i],\n}))\n\nconst TaskAddScreen: React.FC = () => {\n  const { params: { type, id }} = useRoute<TaskAddScreenRouteProp>();\n  const { navigate, goBack } = useNavigation<RootNavigationProp>();\n  const [currentId, setCurrentId] = useState(id || nanoid());\n  const [setTask] = useSetTask();\n  const tasks = useTasks();\n  const [currentType, setCurrentType] = useState<TaskType>(type);\n\n  const locations = useLocations();\n  const [title, setTitle] = useState('');\n  const [maxStart, setMaxStart] = useState<Time>();\n  const [minStart, setMinStart] = useState<Time>();\n  const [duration, setDuration] = useState('');\n  const [hasLocation, setHasLocation] = useState(false);\n  const [selectedLocations, setSelectedLocations] = useState<UserLocation[]>([]);\n  const [hasDays, setHasDays] = useState(false);\n  const [selectedDays, setSelectedDays] = useState<typeof days>([]);\n  const [required, setRequired] = useState(false);\n\n  useEffect(\n    () => {\n      if (!id) {\n        return;\n      }\n      const current = tasks.find(t => t.id === id);\n      if (!current) {\n        return;\n      }\n      setTitle(current.title);\n      setMaxStart(current.startTime.max);\n      setMinStart(current.startTime.min);\n      setDuration(current.duration?.toString() || '');\n      setHasLocation(!!current.locations);\n      setSelectedLocations(current.locations || []);\n      setCurrentType(current.type || TaskType.goal);\n      setRequired(current.required);\n      if (current.type === TaskType.goal || current.type === TaskType.routine) {\n        setHasDays(!!current.days);\n      }\n    },\n    [id],\n  )\n\n  const [save] = useAsyncCallback(\n    async () => {\n      const task: Partial<Task> = {\n        id: currentId,\n        title,\n        type: currentType,\n        required,\n        startTime: {\n          max: maxStart!,\n          min: minStart!,\n        },\n        duration: parseInt(duration),\n        locations: hasLocation ? selectedLocations: undefined,\n      };\n      if (task.type === TaskType.goal || task.type === TaskType.routine) {\n        task.days = hasDays\n          ? new Array(7).fill(undefined).map((_, i) => !!selectedDays.find(d => d.id === i))\n          : undefined;\n      }\n      await setTask(task as Task);\n      navigate('main');\n    },\n    [\n      title,\n      currentId,\n      maxStart,\n      minStart,\n      duration,\n      hasLocation,\n      selectedLocations,\n      hasDays,\n      selectedDays,\n      required,\n    ],\n  );\n\n  return (\n    <Popup title={type ? `Add ${type}` : `Update ${title}`} onClose={goBack}>\n      <Group title=\"Basic\">\n        <TextInput label=\"Title\" value={title} onChangeText={setTitle} />\n        <SideBySide>\n          <TimeInput flex={1} label=\"Min start\" value={minStart} onChange={setMinStart} />\n          <TimeInput flex={1} label=\"Max start\" value={maxStart} onChange={setMaxStart} />\n        </SideBySide>\n        <TextInput\n          label=\"Duration\"\n          value={duration}\n          onChangeText={setDuration}\n          right={<Cell><Overline>min</Overline></Cell>}\n        />\n      </Group>\n      <Group title=\"Optional\" startHidden>\n        <OptionalSelector\n          label=\"Location\"\n          enabled={hasLocation}\n          items={locations}\n          selected={selectedLocations}\n          onChange={setSelectedLocations}\n          render={location => ({\n            title: location.title,\n          })}\n          getKey={location => location.id}\n          setEnabled={setHasLocation}\n          disabledText=\"Anywhere\"\n          enabledText=\"Specific location\"\n        />\n        <OptionalSelector\n          label=\"Days\"\n          enabled={hasDays}\n          items={days}\n          selected={selectedDays}\n          onChange={setSelectedDays}\n          render={day=> ({\n            title: day.name\n          })}\n          getKey={day => day.id.toString()}\n          setEnabled={setHasDays}\n          disabledText=\"Any day\"\n          enabledText=\"Specific days\"\n        />\n          <Checkbox label=\"Required\" onChange={setRequired} value={required} />\n        {type === TaskType.goal && (\n          <SideBySide>\n            <TextInput label=\"Start\" flex={1} />\n            <TextInput label=\"Deadline\" flex={1} />\n          </SideBySide>\n        )}\n      </Group>\n      <Row>\n        <Button onPress={save} title=\"Save\" type=\"primary\" />\n      </Row>\n    </Popup>\n  );\n};\n\nexport { TaskAddScreen };\n","import { TaskType } from \"#/features/data\";\nimport { Page, Row } from \"@morten-olsen/ui/components/base\";\nimport { MoreScreenNavigationProps } from \"#/ui/router\";\nimport { useNavigation } from \"@react-navigation/native\";\n\nconst MoreScreen: React.FC = () => {\n  const { navigate } = useNavigation<MoreScreenNavigationProps>();\n\n  return (\n    <Page>\n      <Row\n        title=\"Calendars\"\n      />\n      <Row\n        title=\"Locations\"\n        onPress={() => navigate('locations')}\n      />\n      <Row\n        title=\"Routines\"\n        onPress={() => navigate('tasks', { type: TaskType.routine })}\n      />\n      <Row\n        title=\"Goals\"\n        onPress={() => navigate('tasks', { type: TaskType.goal })}\n      />\n    </Page>\n  );\n}\n\nexport { MoreScreen };\n","import { useLocations, useRemoveLocation } from \"#/features/location\"\nimport { List, Page } from \"@morten-olsen/ui/components/base\";\nimport { useNavigation } from \"@react-navigation/native\";\n\nconst LocationListScreen: React.FC = () => {\n  const { navigate } = useNavigation();\n  const locations = useLocations();\n  const removeLocation = useRemoveLocation();\n\n  return (\n    <Page>\n      <List\n        items={locations}\n        remove={l => removeLocation(l.id)}\n        getKey={l => l.id}\n        add={() => navigate('set-location', {})}\n        render={(item) => ({\n          title: item.title,\n        })}\n      />\n    </Page>\n  );\n}\n\nexport { LocationListScreen };\n","import { nanoid } from 'nanoid';\nimport { useAsyncCallback } from \"#/features/async\";\nimport { useLocations, useSetLocation } from \"#/features/location\"\nimport { Button, Popup, Row } from \"@morten-olsen/ui/components/base\";\nimport { TextInput } from \"@morten-olsen/ui/components/form\";\nimport { LocationSetScreenRouteProp, RootNavigationProp } from \"#/ui/router\";\nimport { useNavigation, useRoute } from \"@react-navigation/native\";\nimport { useEffect, useState } from \"react\";\n\nconst LocationSetScreen: React.FC = () => {\n  const {\n    params: { id = nanoid() },\n  } = useRoute<LocationSetScreenRouteProp>();\n  const { navigate } = useNavigation<RootNavigationProp>();\n  const locations = useLocations();\n  const [title, setTitle] = useState('');\n  const setLocation = useSetLocation();\n\n  useEffect(\n    () => {\n      const current = locations.find(l => l.id === id);\n      if (!current) {\n        return;\n      }\n      setTitle(current.title);\n    },\n    [id, locations],\n  )\n\n  const [save] = useAsyncCallback(\n    async () => {\n      await setLocation({\n        id,\n        title,\n        position: { longitute: 0, latitude: 0 },\n      });\n      navigate('main');\n    },\n    [id, title],\n  );\n\n  return (\n    <Popup title=\"Edit location\">\n      <TextInput\n        label=\"What should it call the location?\"\n        value={title}\n        onChangeText={setTitle}\n      />\n      <Row>\n        <Button title=\"Save\" onPress={save} />\n      </Row>\n    </Popup>\n  );\n};\n\nexport { LocationSetScreen };\n","import { useRemoveTask, useTasks } from \"#/features/tasks\";\nimport { List, Page } from \"@morten-olsen/ui/components/base\";\nimport { RootNavigationProp, TaskListScreenRouteProp } from \"#/ui/router\";\nimport { useNavigation, useRoute } from \"@react-navigation/native\";\n\nconst TaskListScreen: React.FC = () => {\n  const { \n    params: { type },\n  } = useRoute<TaskListScreenRouteProp>();\n  const { navigate } = useNavigation<RootNavigationProp>();\n  const tasks = useTasks(type);\n  const [removeTask] = useRemoveTask();\n\n  return (\n    <Page>\n      <List\n        items={tasks}\n        remove={removeTask}\n        getKey={l => l.id}\n        add={() => navigate('add-task', { type })}\n        render={(item) => ({\n          title: item.title,\n          onPress: () => {\n            navigate('add-task', { id: item.id })\n          },\n        })}\n      />\n    </Page>\n  );\n}\n\nexport { TaskListScreen };\n","import { useAsyncCallback } from \"#/features/async\";\nimport { Time, timeUtils, UserLocation } from \"#/features/data\";\nimport { useLocations } from \"#/features/location\";\nimport { useTasks } from \"#/features/tasks\";\nimport { Button, Cell, Popup, Row } from \"@morten-olsen/ui/components/base\"\nimport { Checkbox, TextInput, TimeInput, OptionalSelector } from \"@morten-olsen/ui/components/form\";\nimport { RootNavigationProp, TaskAddScreenRouteProp } from \"#/ui/router\";\nimport { Overline } from \"@morten-olsen/ui/typography\";\nimport { useNavigation, useRoute } from \"@react-navigation/native\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport styled from \"styled-components/native\";\nimport { Override, useClearTaskOverride, useOverrides, useSetTaskOverride } from \"#/features/overrides\";\n\nconst SideBySide = styled.View`\n  flex-direction: row;\n  justify-content: flex-end;\n`;\n\nconst dayNames = [\n  'Monday',\n  'Tuesday',\n  'Wednsday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n  'Sunday',\n]\n\nconst days = new Array(7).fill(undefined).map((_, i) => ({\n  id: i,\n  name: dayNames[i],\n}))\n\nconst OverrideSetScreen: React.FC = () => {\n  const { params: { id }} = useRoute<TaskAddScreenRouteProp>();\n  const { navigate, goBack } = useNavigation<RootNavigationProp>();\n  const [setOverride] = useSetTaskOverride()\n  const [clearOverrides] = useClearTaskOverride();\n  const overrides = useOverrides();\n  const tasks = useTasks();\n  const task = useMemo(\n    () => tasks.find(t => t.id === id)!,\n    [tasks, id],\n  );\n\n  const locations = useLocations();\n  const [maxStart, setMaxStart] = useState<Time>();\n  const [minStart, setMinStart] = useState<Time>();\n  const [duration, setDuration] = useState('');\n  const [hasLocation, setHasLocation] = useState(false);\n  const [selectedLocations, setSelectedLocations] = useState<UserLocation[]>([]);\n\n  useEffect(\n    () => {\n      if (!id) {\n        return;\n      }\n      const current = overrides.tasks[id];\n      if (!current) {\n        return;\n      }\n      setMinStart(current.startMin);\n      setMaxStart(current.startMax);\n      setDuration(current.duration?.toString() || '');\n      setHasLocation(!!current.locations);\n      setSelectedLocations(current.locations || []);\n    },\n    [id],\n  )\n\n  const [save] = useAsyncCallback(\n    async () => {\n      const override: Override = {\n        startMin: minStart,\n        startMax: maxStart,\n        duration: duration ? parseInt(duration) : undefined,\n        locations: hasLocation ? selectedLocations: undefined,\n      };\n      await setOverride(id, override);\n      navigate('main');\n    },\n    [\n      id,\n      maxStart,\n      minStart,\n      duration,\n      hasLocation,\n      selectedLocations,\n    ],\n  );\n\n  const [clear] = useAsyncCallback(\n    async () => {\n      await clearOverrides(id);\n      navigate('main');\n    },\n    [id, clearOverrides],\n  );\n\n  if (!task) {\n    return <></>;\n  }\n\n  return (\n    <Popup title={`Overrides for ${task.title}`} onClose={goBack}>\n      <SideBySide>\n        <TimeInput\n          flex={1}\n          placeholder={task.startTime.min ? timeUtils.timeToString(task.startTime.min) : undefined}\n          label=\"Min start\"\n          value={minStart}\n          onChange={setMinStart}\n        />\n        <TimeInput\n          flex={1}\n          placeholder={task.startTime.max ? timeUtils.timeToString(task.startTime.max) : undefined}\n          label=\"Max start\"\n          value={maxStart}\n          onChange={setMaxStart}\n        />\n      </SideBySide>\n      <TextInput\n        label=\"Duration\"\n        value={duration}\n        onChangeText={setDuration}\n        right={<Cell><Overline>min</Overline></Cell>}\n      />\n      <OptionalSelector\n        label=\"Location\"\n        enabled={hasLocation}\n        items={locations}\n        selected={selectedLocations}\n        onChange={setSelectedLocations}\n        render={location => ({\n          title: location.title,\n        })}\n        getKey={location => location.id}\n        setEnabled={setHasLocation}\n        disabledText=\"Anywhere\"\n        enabledText=\"Specific location\"\n      />\n      <Checkbox label=\"Required\" />\n      <TextInput\n        label=\"Priority\"\n        placeholder=\"5\"\n      />\n      <Row>\n        <SideBySide>\n          <Button onPress={clear} title=\"Clear\" type=\"destructive\" />\n          <Button onPress={save} title=\"Save\" type=\"primary\" />\n        </SideBySide>\n      </Row>\n    </Popup>\n  );\n};\n\nexport { OverrideSetScreen };\n","import { useMemo } from 'react';\nimport { PlannedTask } from \"#/features/planner/types\";\nimport chroma from 'chroma-js';\nimport styled from \"styled-components/native\";\nimport stringToColor from 'string-to-color';\nimport { timeUtils } from '#/features/data';\nimport { Body1, CalendarEntry, Row } from '@morten-olsen/ui';\n\ntype Props = {\n  task: PlannedTask;\n  onPress?: () => void;\n};\n\n\nconst Touch = styled.TouchableOpacity`\n`;\n\nconst PlanDayTask: React.FC<Props> = ({ task, onPress }) => {\n  const color = useMemo(\n    () => chroma(stringToColor(task.name)).luminance(0.7).saturate(1).brighten(0.6).hex(),\n    [task.name],\n  );\n  const height = useMemo(\n    () => (timeUtils.timeToMinutes(task.end) - timeUtils.timeToMinutes(task.start)) / 10,\n    [task.start, task.end],\n  );\n  const view = (\n    <Row>\n      <CalendarEntry\n        start={timeUtils.timeToDate(task.start)}\n        end={timeUtils.timeToDate(task.end)}\n        title={task.name}\n      />\n    </Row>\n  );\n\n  if (onPress) {\n    return (\n      <Touch onPress={onPress}>\n        {view}\n      </Touch>\n    );\n  }\n  return view;\n};\n\nexport { PlanDayTask };\n","import { dayUtils } from \"#/features/day\";\nimport { PlanResultDay } from \"#/features/planner\"\nimport { Body1, Jumbo } from \"@morten-olsen/ui\";\nimport styled from \"styled-components/native\";\nimport { PlanDayTask } from \"./task\";\n\ntype Props = {\n  day: PlanResultDay;\n};\n\nconst Transit = styled(Body1)`\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n`;\n\nconst PlanDay: React.FC<Props> = ({ day }) => {\n  if (day.status === 'waiting') {\n    return <></>\n  }\n  if (day.status === 'running') {\n    return <Body1>Running, nodes: {day.nodes}, strategy: {day.strategy}</Body1>\n  }\n  return (\n    <>\n      {day.plan.map((item) => {\n        if (item.type === 'task') {\n          return <PlanDayTask task={item} />\n        }\n        return <Transit>{item.from.title}  {item.to.title}</Transit>\n      })}\n    </>\n  )\n}\n\nexport { PlanDay };\n","import { Day, dayUtils, useDate } from \"#/features/day\"\nimport { usePlan } from \"#/features/planner\";\nimport { Button, Row } from \"@morten-olsen/ui/components/base\";\nimport { CalendarStrip, DateSelector, FormLayout } from \"@morten-olsen/ui\";\nimport { PlanDay } from \"#/ui/containers/plan\";\nimport { useCallback, useState } from \"react\";\nimport styled from \"styled-components/native\";\n\nconst Scroll = styled.ScrollView`\n flex: 1;\n`\nconst Wrapper = styled.View`\n  margin: 60px 0;\n`\n\nconst Horizontal = styled.View`\n`;\n\nconst FlexDateSelector = styled(DateSelector)`\n  width: 100%;\n`;\n\nconst PlanScreen: React.FC = () => {\n  const [start, setStart] = useState<Day>(dayUtils.today());\n  const [end, setEnd] = useState<Day>(dayUtils.today());\n  const [plan, { result }] = usePlan();\n\n  const runPlanning = useCallback(\n    () => plan({\n      start,\n      end,\n      location: { id: 'sdf', title: 'sdf' },\n    }),\n    [start, end, plan],\n  );\n\n  return (\n    <Scroll>\n      <Wrapper>\n        <Horizontal>\n          <FlexDateSelector\n            label=\"Start date\"\n            selected={start}\n            onSelect={setStart}\n          />\n          <DateSelector\n            label=\"End date\"\n            selected={end}\n            onSelect={setEnd}\n          />\n        </Horizontal>\n        <Row>\n          <Button onPress={runPlanning} title=\"Plan\" />\n        </Row>\n        {!!result && (\n          <>\n            <CalendarStrip\n            />\n            {Object.entries(result.days).map(([key, day]) => (\n                <PlanDay day={day} />\n            ))}\n          </>\n        )}\n      </Wrapper>\n    </Scroll>\n  );\n}\n\nexport { PlanScreen }\n","import { useMemo } from 'react';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { useTheme } from 'styled-components/native';\nimport { NavigationContainer, DefaultTheme } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport { Icon } from '@morten-olsen/ui/components/base';\nimport { DayScreen } from '../screens/day';\nimport { TaskAddScreen } from '../screens/task/add';\nimport { MainTabParamList, RootStackParamList } from './types';\nimport { Platform } from 'react-native';\nimport { MoreScreen } from '../screens/more';\nimport { LocationListScreen } from '../screens/locations/list';\nimport { LocationSetScreen } from '../screens/locations/set';\nimport { TaskListScreen } from '../screens/task/list';\nimport { OverrideSetScreen } from '../screens/task/overrides';\nimport { PlanScreen } from '../screens/plan';\n\nconst MoreStackNavigator = createNativeStackNavigator();\n\nconst MoreStack: React.FC = () => (\n  <MoreStackNavigator.Navigator>\n    <MoreStackNavigator.Screen name=\"more-main\" component={MoreScreen} />\n    <MoreStackNavigator.Screen name=\"locations\" component={LocationListScreen} />\n    <MoreStackNavigator.Screen name=\"tasks\" component={TaskListScreen} />\n  </MoreStackNavigator.Navigator>\n);\n\nconst MainTabsNvaigator = createBottomTabNavigator<MainTabParamList>();\n\nconst MainTabs: React.FC = () => {\n  const theme = useTheme();\n  return (\n    <MainTabsNvaigator.Navigator\n      screenOptions={{\n        tabBarActiveTintColor: theme.colors.primary,\n      }}\n    >\n      <MainTabsNvaigator.Screen\n        options={{\n          headerShown: false,\n          tabBarLabel: 'Days',\n          tabBarIcon: ({ focused }) => <Icon color={focused ? 'primary' : 'text'} name=\"check-square\" />,\n        }}\n        name=\"day\"\n        component={DayScreen}\n      />\n      <MainTabsNvaigator.Screen\n        options={{\n          headerShown: false,\n          tabBarLabel: 'Plan',\n          tabBarIcon: ({ focused }) => <Icon color={focused ? 'primary' : 'text'} name=\"check-square\" />,\n        }}\n        name=\"plan\"\n        component={PlanScreen}\n      />\n      <MainTabsNvaigator.Screen\n        options={{\n          headerShown: false,\n          tabBarLabel: 'More',\n          tabBarIcon: ({ focused }) => <Icon color={focused ? 'primary' : 'text'} name=\"more-vertical\" />,\n        }}\n        name=\"more\"\n        component={MoreStack}\n      />\n    </MainTabsNvaigator.Navigator>\n  );\n};\n\nconst RootNavigator = Platform.OS === 'web'\n  ? createStackNavigator<RootStackParamList>()\n  : createNativeStackNavigator<RootStackParamList>();\n\nconst Root: React.FC = () => (\n  <RootNavigator.Navigator screenOptions={{ headerShown: false, animationEnabled: true }}>\n    <RootNavigator.Group>\n      <RootNavigator.Screen name=\"main\" component={MainTabs} />\n    </RootNavigator.Group>\n    <RootNavigator.Group screenOptions={{ presentation: 'transparentModal' }}>\n      <RootNavigator.Screen name=\"add-task\" component={TaskAddScreen} />\n      <RootNavigator.Screen name=\"set-location\" component={LocationSetScreen} />\n      <RootNavigator.Screen name=\"set-override\" component={OverrideSetScreen} />\n    </RootNavigator.Group>\n  </RootNavigator.Navigator>\n);\n\nconst Router: React.FC = () => {\n  const theme = useTheme();\n  const baseTheme = useMemo(\n    () => DefaultTheme,\n    [],\n  );\n  const navigationTheme = useMemo(\n    () => ({\n      ...baseTheme,\n      colors: {\n        ...baseTheme.colors,\n        background: theme.colors.shade,\n        card: theme.colors.background,\n        text: theme.colors.text,\n      }\n    }),\n    [baseTheme, theme],\n  );\n  return (\n    <NavigationContainer theme={navigationTheme}>\n      <Root />\n    </NavigationContainer>\n  )\n};\n\nexport { Router };\n","import { registerRootComponent } from 'expo';\nimport './setup';\n\nimport { App } from './app';\n\n// registerRootComponent calls AppRegistry.registerComponent('main', () => App);\n// It also ensures that whether you load the app in Expo Go or in a native build,\n// the environment is set up appropriately\nregisterRootComponent(App);\n\n","import 'react-native-get-random-values';\nimport { StatusBar } from 'expo-status-bar';\nimport { SafeAreaProvider } from 'react-native-safe-area-context';\nimport { useCallback } from 'react';\nimport { Setup } from './features/setup';\nimport { Router } from './ui/router';\nimport { Provider } from '@morten-olsen/ui';\n\nconst App: React.FC = () => {\n  const getTransit = useCallback(\n    async (from: any, to: any) => ({\n      to,\n      from,\n      time: 45,\n      usableTime: 0,\n    }),\n    [],\n  )\n  return (\n    <SafeAreaProvider>\n      <StatusBar />\n      <Provider>\n        <Setup getTransit={getTransit}>\n          <Router />\n        </Setup>\n      </Provider>\n    </SafeAreaProvider>\n  );\n};\n\nexport { App };\n"],"sourceRoot":""}